## Java 내용 정리

1. JDK, JRE, JVM
2. Java의 특징
3. JSP, Servlet
4. 

## 기타

### 앞으로 공부할 내용..

#### 출처

> https://ryumso86.tistory.com/28
>
> [렴소네 블로그]



**1. ERP(Enterprise Resource Planning)**

① 전산적 자원 관리 시스템.

② 기업의 모든 자원을 전체적으로 관리하여 최적화된 기업 활동을 통합, 관리 시스템에 근거하여 스피드 경영과 투명 경영의 효과를 꾀하는 것.

**2. Framework**

① 특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의  집합.

② 장점 : 재사용성, 단순성, 역할구분, 확장성, 유지보수용이.

③ 프레임웍과 라이브러리 차이

☞ 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음.

☞ 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공.

**3. Struts2**

① Struts2 : MVC패턴을 지원하고, 웹 어플리케이션을 개발하기 위한 프레임워크.

② 특징 : ☞ Struts1 + Webwork2의 아키텍처 적용.

☞ POJO(Plain Old Java Object) 기반 액션 사용.

☞ Zero configration(설정 없이) 지향.

☞ Ajax기능을 태그와 테마 기반으로 구성.

☞ 다양한 표현식 언어 사용 가능(JSTL, OGNL).

③ MVC 모델에서 커버하는 부분 : Controller 지원.

④ 실행 순서(실행구조) :

☞ web.xml의 등록된 FilterDispatcher를 통해서 요청에 대해 진입.

☞ FilterDispatcher 에선 모든 요청을 처리하고, ActionPloxy 생성.

☞ ActionPloxy가 생성되면, FilterDispatcher가 실행 권한을 이임.

☞ Configuration은 struts.xml을 통해서 설정관리자를 초기화함.

☞ 초기화 후, Action invocation 실행.

☞ 실행할 Interceptor가 있으면 실행 하고, Action으로 전달.

☞ Action에서 결과 값을 통해, 해당 Template으로 이동.

☞ Interceptor자원 반납 후 응답.

**4. Spring**

① Spring : Java Enterprise Application 개발에 사용 되는 Application Framework. 개발을 빠르고 효율적으로 할 수 있도록Application의 바탕이 되는 틀과 공통프로그래밍 모델, 기술 API를 제공.

② 특징 : ☞ 스프링은 종속객체주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음.

☞ AOP를 이용하여 객체지향만이 아닌 관심지향 기법을 활용.

☞ EJB 기능을 대체 할 수 있음. 트랜젝션 처리를 위한 일관된 방법을 제공.

☞ 레이어간 연결이 interface로 이루어지기 때문에 interface 생성이 필요.

☞ 다양한 프레임워크와의 통합.

③ MVC 모델에서 커버하는 부분 : Controller 지원.

④ 실행 순서(실행구조) :

☞ web.xml의 등록된 DispatcherServlet를 통해서 요청에 대해 진입.

☞ DispatcherServlet은 Client로부터 들어온 URL을 HandlerMapping 라는 곳으로 전송 후 URL을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet으로 보냄.

☞ HandlerMapping이라는 것을 통해서 실행될 Controller의 이름을 입력받은 DispatcherServlet은 전달받은 Controller를 실행시킴.이렇게 실행된 Controller는 스프링에서 제공하는 ModelAndView 객체에 뷰 페이지에 전달할 객체와 View Page 이름 정보를 담고 DispatcherServlet으로 보냄.

☞ ViewResolver를 통해 보여 질 View페이지를 탐색한 후 View페이지를 보여줌.

**5. DI 와 AOP의 대해 설명하시오.**

① DI : Dependency Injection의 약자 의존성 주입이란 뜻.

스프링을 적용하여 applicationContext.xml에서 설정만 해주면, 외부 설정파일(xml)에서 연관관계에 있는 객체를 주입해주기 때문에 의존객체를 찾기 위한 코드가 필요하지 않게 됨. 즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요.

② AOP : Aspect oriented programming의 약자 관심지향 프로그래밍.

프로그래밍을 할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써, 기존 객체지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 제거 할 수 있게 됨.

**6. iBatis**

① Java에서 DataBase를 편하게 Handling 할 수 있게 해주는 프레임 워크.

② 특징 : SQL문과 Java코드와의 분리 만으로도 Java개발자는 Query문을 신경쓰지 않아도 됨. SQL문이 변경되더라도 파라미터 값만 변경 되지 않는 다면 Java소스에서 수정할 부분이 없기 때문.

③ MVC 모델에서 커버하는 부분 : Model 지원.

④ 실행 순서(실행구조) :

☞ 자바 코드 내에서 특정 쿼리문을 실행하기 원할 때, 파라미터와 필요한 조건을 넘기기 위한 객체를 생성.

☞ SQLMaps를 실행하기 위해 쿼리의 객체와 이름을 넘겨줌.

☞ 쿼리가 실행되었을 때 SQLMaps는 쿼리 결과를 받기 위해 정의 된 클래스의 인스턴스를 생성하게 됨.

☞ 인스턴스는 데이터베이스에 의해 반환 된 ResultSet 으로부터 만들어짐.

**7. MVC 패턴이란 ?**

- Model, View, Control의 역할을 확실하게 분리시켜놓는 프로그래밍 기법.

**8. WAS (Web Application Server)**

① WAS : Web Application Server의 약자.

☞ 서버와 클라이언트 사이에 있는 3-tier 방식으로서, Server가 처리하는 양이 많아지면서 Server에 생기는 부하를 해결하기 위해 개발 됨.

☞ Client에서 요청이 들어오면 실제적인 처리는 WAS가 하고 서버는 단지 Client에 결과 값을 뿌려주는 역할만 하게 됨.

② 대표적인 제품 : 톰캣, 웹스피어, 웹로직, 제우스등.

**9. String, StringBuffer, StringBuilder의 차이점**

① String 클래스 : 상수문자열, 한번 생성한 후 변하지 않는 문자열 용도

② StringBuffer 클래스 : 프로그램 내에서 계속 변하는 문자열 용도

③ StringBuilder 클래스 : StringBuilder는 Java5 에 추가된 클래스로 StringBuffer와 기능이 같다.

☞ 차이점 : StringBuffer은 동기화(synchronized)되지만 StringBuilder는 그렇지 않다.

즉, StringBuilder은 다중 thread에서는 안전하지 않으므로 동기화가 필요한 경우에는 StringBuffe은 사용하는 것이 좋다.

StringBuilder ->동기화를 하려면 synchronized블록으로 감싸야 한다.

**10. Java Servlet**

- 자바를 사용하여 웹페이지를 동적으로 생성하는 서버 측 프로그램.

**11. Index**

① 인덱스를 사용하는 이유

\- 인덱스를 만드는 이유는 가장 큰 이유가 데이터를 빠르게 검색하기 위함입니다

\- 인덱스를 만드는 두번째 이유는 Row의 유일성을 유지하기 위한 것입니다

② 인덱스 사용 시 단점

\- 인덱스를 만들게 되면 그 정보를 유지하기 위해서 디스크 공간도 필요하게 되고, 인덱스가 걸려 있는 테이블은 인덱스가 없을 때보다 데이터를 추가하거나 변경할 때 많은 시간이 소요 됩니다

③ 인덱스의 종류

- Unique Clustered Index         - Nonunique Clustered Index
- Unique Nonclustered Index       - Nonunique Nonclustered Index

④ 클러스터드 인덱스는

\- 한 테이블에 단 한개만 존재할 수 있습니다.

\- 범위(Range)를 주어 검색 할 때 탁원한 기능을 발휘합니다.

예) 키순으로 서세요, 나이순으로 서세요. 이름순으로 서세요

⑤ 넌클러스터드 인덱스(Nonclustered Index)는

\- 한 테이블에 여러개 존재할 수 있습니다.

\- 특정한 값으로 찾아갈 때(Seek) 탁월한 성능을 발휘합니다.

예) 도서명, 저자명, 분야명

**12. 트랜젝션, 롤백, 커밋**

① 트랜젝션 : 일련의 작업단위로 특성으로 ACID(원자성,일관성,고립성,영구성)가 있음.

② 트랜젝션의 필요성 : 여러작업이 한 자원에 동시에 변경, 참조가 필요한 경우, 작업공정이 긴 경우.

③ 트랜젝션의 시작 :

☞ 첫 DML(데이터조작어)구문이 실행될 때.(SELECT에선 제외)

☞ 사용자가 SAVEPOINT를 설정할 때.

④ 트랜젝션의 종료 :

☞ commit 수행.  ☞ rollback 수행.

☞ DDL(데이터정의어), DCL(데이터제어어)이 실행될 때.

☞ 오라클 내부에서 자동 commit 수정.

☞ 사용자가 sqlplus를 종료할 때, 시스템 크래쉬 발생.

⑤ 커밋과 롤백 전

☞ 롤백으로 데이터 회복가능.

☞ 현재 유저는 자신이 바꾼 데이터를 확인할 수 있다.

☞ 다른 유저에게는 바뀐 데이터 내용이 반영되지 않음.

☞ 영향을 받은 레코드는 잠금 상태.

⑥ 커밋 후

☞ 데이터는 영구적으로 변경.

☞ 복구 불가능.

☞ 모든 유저에게 변경 내용이 반영.

☞ 해당 레코드의 잠금 해제, 다른 유저들이 다룰 수 있음.

☞ 세이브 포인트가 삭제.

⑦ 롤백 후

☞ 데이터의 변경이 취소.

☞ 데이터의 이전 상태가 회복.

☞ 데이터에 대한 잠금이 해제.

**13. C와 C++의 차이점**

① C : 함수 기반 절차함수 기능만 가지고 있음.

필요하면 함수 prototype을 만들어서 함수 본문을 만들어서 추가.② C++ : 클래스 기반 컴파일러 단에서 "클래스" 라는 객체지향적 방법을 지원.     클래스에서 생성자/소멸자 등을 사용하여 자원 관리를 자동화 할 수 있음.     연산자 재정의가 가능.

**14. 다형성**

- 객체지향개념에서의 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램 적으로 구현.

**15. Overloading(메소드 중복정의) 과 Overriding(메소드 재정의)**

① Overloading : 기존에 메소드의 인자를 이용하여서 하나의 함수에 여러가지 기능을 만드는 것.

② Overriding : 상위 클래스에 있는 메서드와 똑같은 메서드를 하위 클래스에서 다시 만드는 행위를 말함. 즉 하위 클래스에서 메서드를 재 정의하는 것을 말함. 주로 생성자 메소드를 정의할 때 많이 사용.

**16. 정적 변수, 지역변수, 전역변수를 스택과 힙과 관련에서 설명**

① 전역변수 : 프로그램에서 전반적으로 다 사용이 가능.

함수 밖에서 정의해 놓으면 다른 함수에서도 사용할 수 있음.

② 지역변수 : 함수 안에서만 사용이 가능한 변수, 다른 함수에서는 사용을 못함.

③ 정적변수 : 한번 정의 하면 그 값은 계속적으로 메모리에 남아 있음.

프로그램이 종료될 때, 메모리에서 지워짐.

함수 안에서 사용해도 함수가 끝날 때 지워지지 않음.

**17. OSI 7 Layers (OSI 7계층 구조)**

- 7계층: 응용 계층 (application layer)
- 6계층: 표현 계층(presentation layer)
- 5계층: 세션 계층(session layer)
- 4계층: 전송 계층(transport layer)
- 3계층: 네트워크 계층(network layer)
- 2계층: 데이터링크 계층(data link layer)
- 1계층: 물리 계층(physical layer)

① 개요

컴퓨터 통신 분야에서 동일 업체 또는 유사 업체끼리의 다양한 표준들이 양산됨에 따라 표준을 정의하는 골격으로서의 국제적인 기준 모델이 필요하게 되었다. 따라서 네트워크 상호간의 접속을 목적으로 각종 규격 개발적업을 조정하기 위한 공통 기반을 제공하고 각 사업자별로 개발된 기존 규격에 대하여는 이러한 참조 모델에 쉽게 적응 연결토록 하는 편의성을 제공하고자 했다.

② 표준화를 위한 기본 골격

IOS의 개방형 시스템간 상호 접속 모델(Open System Interconnection model)은 각 계층에서 표준이 개발, 발전될수 있도록 기본들을 제공하며 프로토콜의 발전을 유도, 인도하는데 그 목적이 있다, 결론적으로 OSI 참조모델은 참조모델이라기 보다는 표준의 표준으로써 다만 표준화를 유도하기 위한 기본 골격에 불과하는 것이다.

③ 계층간독립성

각 계층별로 독립시킨다는 것은 융통성(flexibiltty)을 부여하게 된다.

예를 들면 보다 좋은 성능을 가진 전기적 인터페이스가 개발되면 상위계층에게 영향을 미치지 않고 성능을 향상시킨 채 교체가 가능하기 때문이다.

④ 계층내 프로토콜

OSI가 각 계층별로 하나의 프로토콜만이 존재하는 그릇된 생각을 할수 있는데 이는 잘못된 생각이며 사실 각 층을 구현하기 위한 다양한 프로토콜이 존재한다. 그러나 같은 계층에 있는 여러 다른 기능의 프로토콜은 바로 하위 계층에서 제공하는 서비스를 공유하여야 한다.

⑤ 연결 지향성 및 비연결성

OSI는 초기에는 연결 지향성 서비스 위주의 프로토콜들에만 관심을 가져왔으나 후에 비연결성에도 관심을 가지게 되었다.

**18. 프로그램을 개발하는데 제일 중요한 것?**

(정답이 없음 주관적으로 답할 것)

참고) 프로젝트 진행과정

요구사항분석 - 설계(데이터베이스, 클래스, 화면) - 개발 - 테스트 - 이관/교육 - 프로젝트 종료

**19. JAVA의 특징**

- 플랫폼에 독립적인 객체지향언어, 플랫폼에 독립적이라는 것은 리눅스 그리고 윈도우 등과 같은 개발환경에 제약을 받지 않고, 어느 플랫폼에서나 코드의 호환성과 재사용이 자유롭다는 것을 의미.

**20. Stack 과 Q**

- Stack 과 Q는 컴퓨터의 알고리즘에서 가장 흔하게 사용되는 자료 구조.

① Stack :

모든 작업이 리스트의 한쪽 끝에서만 수행되는 선형 리스트의 한 형태로, 리스트의 한쪽 끝(TOP)에서 원소를 삽입하거나 제거하는데 사용. 그러므로 리스트에서 스택에 마지막으로 입력된 원소가 제일 먼저 제거의 대상이 됨. 그래서 스택을 LIFO (Last In First Out) 라고도 함.

② Q방식 :

삽입은 REAR에서 이루어지고, 제거는 FRONT에서 이루어짐. 큐에 A, B, C, D, E순으로 원소가 삽입되었다면, 제일 먼저 제거되는 원소는A. Q는 FIFO(First In First Out)라고 함.

**21. ERD란?**

☞ Entity Relationship Diagram의 약자로 개체관계도. 말로서 되어있는 요구분석사항을 그림으로 그려내어 그 관계를 도출하는 것.

**22. JSP를 구동하기 위해 서버를 구축하는 과정**

① 자바 인스톨 :

☞ JDK 인스톨.

☞ JRE 인스톨(JDK를 설치하면 설치가 되기 때문에 따로 설치할 필요는 없음)

② 환경변수 setting : ☞ 컴퓨터의 환경변수를(Path)를 잡아야 함.

③ 미들웨어 : JSP를 웹으로 변환 해줄 수 있는 톰캣 설치.

**23. JSP는 무엇이며 JSP의 특징**

① JSP란? : Java Servet Pages 의 약자로써 자바를 기반으로 하고 있는 스크립트 언어.

② 특징 : ☞ 자바언어를 기반으로하는 스크립트 언어로써 자바의 장점을 사용 할 수 있음.

☞ 자바언어를 기반으로 하고 있기 때문에 플랫폼에 상관없이 사용할 수 있음.

☞ 표현언어, 표현식, 스크립틀릿 등의 다양한 스크립트 요소와 액션 태그등을 제공함으로써 보다 쉽게 웹 어플리케이션을 개발 할 수 있음.

☞ 서블릿/EJB 등의 엔터프라이즈 기술들과 잘 융합됨.

**24. AJAX는 무엇이며 AJAX의 특징**

① AJAX란? : 웹클라이언트 화면 제어를 보다 세밀하게 하기 위한 기술

② 특징 : ☞ 필요한 데이터만 서버로 보내고 해당 정보만 받음.

서버로부터 정보를 받을때는 xml 이나 json 형태로 받고 클라이언트에서는 그 정보들을 DOM을 통해 화면을 재가공 하여 보여주기 때문에, 서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음. 클라이언트에서 데이터를 처리하므로 서버에 부담이 덜 가기 때문에 다른 응답요청에 신속히 응대 할 수 있음.

**25. WIPI는 무엇이며 WIPI의 특징**

- WIPI란? : 한국무선인터넷 표준화 포럼(KWIS)에서 만든 모바일 플랫폼 표준 규격으로 무선인터넷을 통해 다운로드 된 응용프로그램을 이동통신 단말기에 탑재시켜 실행시키기 위한 환경을 제공하는 표준 규격.
- 특징 : C/C++/Java 복수 언어 모두 지원함으로서 다양한 컨텐츠 개발자들을 수용할 수 있도록 함.

동적 링킹 라이브러리(DLL; Dynamic Linking Library)를 지원함에 따라 플랫폼의 API를 동적으로 추가 혹은 갱신할 수 있음.

**26. XML은 무엇이며 XML의 특징**

- XML이란? : 사용자 정의 태그를 통해 텍스트 데이터의 구조화된 문서 저장과 application 간의 문서 교환을 위해 1986년 ISO에 제안된 마크업 언어. SGML의 일부 기능과 인터넷에서 이용하기 쉬운 HTML의 장점을 도입하여 개발한 언어.
- 특징 : 사용자 정의 태그가 가능하며, 텍스트 데이터를 구조화하고 전송할 목적(텍스트 데이터의 재사용과 정보 검색 용이) Application and WebApplication 모두 사용 가능

**27. 객체(object)**

- 효율적으로 정보를 관리하기 위하여 사람들이 의미를 부여하고 분류하는 논리적인 단위이다. 프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성된 것을 말함.

**28. 클래스**

- 객체를 만드는 설계도(객체를 생성하는 틀의 개념)

**29. 객체와 인스턴스**

- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.

**30. 객체 지향 프로그래밍(Object-Oriented Programming, OOP)**

- 컴퓨터 프로그래밍의 패러다임의 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음.

① 캡슐화 (Encapsulation) 하나의 문제를 해결하기 위한 데이터와 메서드를 하나의  단위로 묶는다는 것으로서, 클래스의 내부 정의에 대해 외부에서 볼 수 없도록 하는 것이 특징(은닉화).

② 추상화 (Abstraction) 모델(Object)의 자세한 성질을 무시하고(숨기고) 그들의 일 반적인 성질을 나타낸다는 것으로서, 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의 공통적인 성질과 행위를 일반화하여 디자인 되게 되며 그로부터 생성된 객체는 자신의 고유의 성질을 가지게 됨.

③ 다형성 (Polymorphism) 다형성이란 같은 메시지에 대해 클래스에 따라 다른 행 위를 하게 되는 특징. 일반적으로 같은 이름을 가지는 메서드에 대해 인자(Argument)의 개수와 데이터 형(Data Type)에 따라 수행되는 행위가 달라짐을 의미. 다형성을 통해서 사용자는 약속된 인터페이스를 따르는 서로 다른 객체를 같은 방식으로 사용 할 수 있게 됨.

④ 상속 (inheritance) 기존에 있던 클래스를 바탕으로(즉, 기존의 클래스로부터 상속받음) 다른 특성을 추가해 새로운 클래스를 만들 수 있음.

⑤ 인스턴스(instance) 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿(무엇인가를 만들 때 안내역할을 하는데 사용되는 형식(꼴), 틀 또 는 모형 등을 의미)이 실제 구현된 것.

**31. 자바언어와 기존의 언어와의 다른 특징**

- 포인터를 사용하지 않는다. (포인터는 존재, 연산을 허용하지 않음)
- 자동으로 쓰레기 수집(garbage collection) 기능을 수행한다.
- 엄격한 형 검사(strict type checking)를 수행하여 에러를 조기에 발견한다.
- 실행시간에 발생하는 에러를 처리한다.

**32. 스레드(Multi threaded)**

- 하나의 프로그램이 동시에 하나 이상의 처리(process)를 수행하는 것을 의미한다.

**33. 디버깅**

- 버그(결함) 에러를 수정하는 것.

**34. DBMS**

- Database Management System, 데이터베이스 매니저먼트 시스템, 응용프로그램이 데이터에 대한 액세스가 가능하도록 DB를 관리하는 소프트웨어 기능, 데이터가 저장되어 있는 장소.

**35. RDBMS**

- 관계형 데이터베이스 관리시스템, 일반적으로 관계형 데이터 모델에 기반한 데이터베이스를 관계형 데이터 베이스라고 함.
- 특징 : ☞ 데이터를 테이블로 표현하고 테이블을 집합으로 받아들임.

☞ 데이터를 조작하는 데는 집합론에 기초한 수학적인 연산을 테이블에 대해 실행.

**36. InnerClass 를 쓰는 이유**

- 내부 클래스를 사용하면 같은 패키지에 있는 다른 클래스한테 까지도 숨길 수 있기 때문에 outer class를 통하지 않고서는 접근할 수 없음. 보안성이 좋아짐.

**37. 미들웨어**

- Middleware, 최근 네트웍 상호 호환과 연동상태를 관리하는 분산 환경에 관심을 갖고 데이터베이스, 스프레드쉬트, 윈도우 OLE등 다양한 소프트웨어를 다루는 데 더 관심을 갖음. 이러한 공통의 인터페이스를 준수하는 컴포넌트 기반의 소프트웨어는 많은 장점을 제공함. 이러한 공통의 인터페이스를 프레임웍=미들웨어(Middleware)라고 함

**38. 서블릿(Servlet)**

- 서버용 애플릿, 웹서버에서 실행되는 작은 자바 코드. JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함.
- 웹브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름.
- 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용.

**39. API:자바 API(Application Programming Interface)**

- 자바개발 환경에서 제공되는 거대한 패키지. 자바언어는 작고 단순한 대신 많은 기능들을 제공하는 라이브러리를 API로 가지고 있음.

**40. Applet**

- 자바 애플릿 프로그램은 애플릿 뷰어(JDK에 포함)나 www(웹)검색기(웹브라우저)에 의해 실행되는 작고 간단한 프로그램.
- 일반적으로 애플릿 프로그램들은 인터넷과 연동된 웹 서버로부터 사용자의 컴퓨터로 다운로드 되어 검색기 상에서 실행됨.
- 애플릿 프로그램은 실행명령에 의해 실행되지 않고 웹의 HTML 코드내에서 호출되는 실행형태를 가지고 있음.

**41. OOL**

- Object Oriented Language, 객체지향 언어.

**42. OOP**

- Object Oriented Programming, 객체지향 프로그램.

**43. import ?**

- C/C++의 #include 선행처리문과 비슷, 헤더파일의 선언을 위해 필요한 구문, 인터프리터에게 클래스를 띄우라는 지시자의 역할을 함.

**44. 예외처리의 필요성과 목적**

- 자바에서 프로그램의 실행하는 도중에 예외가 발생하면 발생된 그 시점에서 프로그램이 바로 종료가 된다. 때에 따라서는 예외가 발생 했을 때 프로그램을 종료시키는 것이 바른 판단일 수도 있다. 하지만 가벼운 예외이거나 예상을 하고 있었던 예외라면 프로그램을 종료시키는 것이 조금은 가혹(?)하다고 느껴진다. 그래서 ‘예외처리’라는 수단(mechanism)이 제안되었고 예외 처리를 통해 우선 프로그램의 비정상적인 종료를 막고 발생한 예외에 대한 처리로 정상적인 프로그램을 계속 진행할 수 있도록 하는 것이 예외처리의 필요성이라 할 수 있다
- 예외의 발생으로 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상 적인 실행 상태를 유지 할 수 있도록 하는 것.

**45. Abstract 클래스**

- 추상 메소드를 하나이상 가지는 클래스.
- new로 객체를 생성할 수 없음.
- 상속받은 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있음.

(추상클래스 끼리의 상속은 메소드 재정의가 필요없음 사용할 때 일반 클래스에서 재정의)

- 추상 메소드란 함수의 리턴타입과 파라메터만 있고 정의부분의 없는 함수를 말함.

**46. 추상화**

- 구체적인 개념으로부터 공통된 부분들만 추려내어 일반화 할 수 있도록 하는 것을 의미.

일반적으로 사용할 수 있는 단계가 아닌 아직 미완성적 개념.

**47. Interface**

- 상수 또는 추상메소드만 정의 할 수 있음.
- 구현된 메서드는 포함 할 수가 없음.
- 모든 변수는 static이고 final임.
- 자식클래스들이 공통된 메서드를 포함하도록 하는 기능만 함.
- 다중 상속이 가능함.

**48. 추상클래스와 인터페이스의 공통점**

- 객체를 발생시킬 수 없음.
- 상속해서 하위 class를 통하여 객체를 발생시킴.(메소드를 재정의 해야 함.)

**49. Camel 규칙 (변수이름 정하는 규칙)**

① 클래스 : 첫 문자는 대문자로 시작. 둘 이상의 단어가 묶어 구성할 때는 새로 시작하는 단어는 대문자로 함.

② 메소드 : 첫 문자는 소문자로 시작. 둘 이상의 단어가 묶어 구성할 때는 새로 시작하는 단어는 대문자로 함.

③ 상수 : 모든 문자를 대문자로 구성. 둘 이상의 단어가 연결될 경우는 _(언더바)를 사용하여 연결 함.

**50. JVM의 구성**

① 클래스영역 : 클래스코드를 저장하는 영역.

② 자바스택 : 메서드를 호출할 때 관련 정보를 저장하는 영역.

③ 힙(Heap) : new라는 키워드를 통해 객체가 생성될 때 할당받는 영역.

④ 네이티브 메서드 스택

**51. Collection에서 데이터를 저장 하는 3가지와 그 특징**

① Set : 순서가 없고, 동일한 데이터 허용이 안 됨.

② List : 배열과 같은 구조지만, 가변적 길이를 가지고 있음(크기가 지정 되어있지 않음)

③ Map : key 값과 value값의 형식으로 저장되면 key값은 절대 중복이 안 됨.

**52. 스트림이 무엇이며 스트림의 특징은?**

① 스트림 : 데이터를 목적지로 입 · 출력하기 위한 방법. 스트림에 데이터를 쓸 수 있고, 데이터를 읽을 수 있음. 연결하고자 하는 Device에 따라 다양한 스트림이 존재.

② 특징 : 스트림은 FIFO 구조. 읽기, 쓰기가 동시에 되지 않음. 읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야함. 데이터가 처리 되기 전까지 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지 블락킹 상태에 빠짐.

**53. 동기화**

- 여러 명이 접근 하는 것을 방지하기 위함.
- 여러 명이 접근 하는 것을 막기 위해 모든 객체에 락을 포함 시키는데, 락이란 공유 객체에 여러 스레드가 동시에 접근하지 못하도록 하기 위한 것으로 모든 객체가 힙 영역에 생성될 때 자동으로 만들어 짐.

**54. 더블버퍼링을 사용하는 이유**

- 이미지를 출력 시키는 경우 화면을 지웠다가 다시 그리게 되면 깜박거리게 됨. 이러한 문제점을 해결하기 위해, 화면에 직접 이미지를 그리지 않고 메모리상에 미리 그려놓고 필요할 때 한번만 화면에 출력 시키는 방법으로 출력 시 깜박거림을 최소화 시켜줌.

**55. AWT와 Swing의 차이점**

- AWT : flatform에 종속. 중량 Component. Frame 자체에 분할. 범용 Component.
- Swing : flatform에 자유로움. 경량 Component. Frame 포함 멤버 분할. Local Component.

**56. Statement 와 PreparedStatement의 차이**

① Statement : 정적 쿼리 시 사용. 매번 파싱과정을 거쳐야 함.(부하가 생길 수 있음) SQL문 전체를 명확히 알 수 가 있어서 디버깅이 쉬움.

② PreparedStatement : 동적 쿼리 시 사용. 한번 파싱하면 그 동일한 SQL문장을 곧바로 파싱 과정 없이 Execution 할 수 있음.(반복적인 다량의 SQL 수행 시 성능 상 이득이 있음) 오류발생 시, 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움.

**57. 서블릿의 실행 과정**

- 서버가 클라이언트의 연결 요청을 받음.
- 웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를 담고있는 Response 객체를 생성.
- 접수된 Url을 분석 후 해당 서블릿 객체를 생성하고, 사용자의 요청을 처리하기 위해 스레드를 생성 후 service() 메소드에 인자값을 담아 호출.
- service() 메소드는 Request 객체를 참고하여 어떤 연결 요청 방식(GET 방식인지 POST 방식인지)으로 들어왔는지 파악 함.
- 들어온 요청 방식에 따라 get 방식은 doGet() 메소드를 post 방식은 doPost() 메소드를 호출하여 처리 함.
- service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여줌.
- 사용자 요청을 처리하기 위해 생성한 스레드를 소멸.

**58. 서블릿에서 데이터를 처리 하는 방식에는 무엇이 있으며 그 특징은?**

① GET : 서버에 있는 정보를 가져오기 위해 설계 됨. 240바이트까지 전달 할 수 있음. POST 방식에 비해 속도가 빠름. URL노출로 보안성이 요구되는 경우엔 사용 할 수 없음. 검색엔진에서 검색단어 전송에 많이 이용함.

② POST : 서버로 정보를 올리기 위해 설계 됨. 데이터크기의 제한이 없음. GET 방식에 비해 속도가 느림. URL에 파라미터가 표시 되지 않음. 내부적으로 데이터가 이동함.

**59. JSP 에서 페이지 이동 방법의 대해 설명 하시오.**

① Forward 방식 :

Url이 바뀌지 않음. 요청객체와 응답객체가 유지됨. 속도가 빠르며 요청객체에 소속 되어 있음.

- Forward 처리 구조 :

☞ 요청이 들어오면 Servlet이 받음.

☞ 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답.

☞ 알맞은 페이지가 없다면, Forwarding 방식으로 알맞은 페이지로 넘기는데, 요청객체와 응답 객체를 포함해 넘김.

☞ Url이 바뀌지 않은 상태로 응답 페이지를 통해 응답.

② Redirect 방식

Url이 바뀜. 요청객체와 응답객체가 유지 되지 않음 속도가 느리며, 응답객체에 소속 되어 있음.

- Redirect 처리 구조 :

☞ 요청이 들어오면 Servlet이 받음.

☞ 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답.

☞ 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청을 하게끔 응답을 보냄.

☞ 클라이언트는 응답을 받고, 다시 그 요청의 맞는 Url로 요청함.

**60 자바 빈즈 란?**

- 자바에서 사용하는 컴포넌트.(부품) Bean은 자바에서 컴포넌트를 이용하기 위해 만들어 놓은 기술.컴포넌트를 사용하면 좋은 이유는 필요 할 때마다 가져다가 사용 할 수 있다는 점인데, JSP에서 자바의 컴포넌트를 이용해서 프로그래밍 하는 것을 빈즈 프로래밍이라 함.

**61. Connection Pool 개념**

- 미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념. 미리 생성할 때 너무 조금 생성하면 오히려 타임오버헤드가 늘어나고, 반대로 너무 많이 생성하면 메모리 오버헤드가 늘어남.

**62. Singleton의 대해 설명 하시오**

\- 발전된 형태의 전역 변수.

\- 프로그램 상에서 두 번째 인스턴스 를 만들 수 없게 하는 기능.

\- 만들어진 클래스의 객체를 단 하나만 사용하며 어디서든 그 객체를 사용할 수 있도록 만들어 줌.

**63. Cookie 와 Session 의 차이**

① Cookie : 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음. 사라지는 때(시간)를 지정 할 수가 있음.

② Session : 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김. 해당 클라이언트와 일정시간동안 작용이 없으면 서버메모리에서 해제 됨. 직접적으로 해제 시킬 수 있는 method가 있음.

**64. Model 1 방식 과 Model 2 방식의 특징과 차이점**

① Model 1

디자인 코드와 자바 코드(비즈니스로직)를 구분하지 않고, 하나의 JSP 일 내에 기술해서 웹 프로그램을 제작 하는 방식.

- Model 1 특징 :

☞ 개발하기가 쉽고, 배우기가 쉬움.

☞ 디자인코드와 비즈니스로직의 구분이 명확하지 않아, 복잡도가 높음.

☞ 수정 시 디자이너와 개발자의 협업이 필요.

☞ 비즈니스로직의 재 사용성이 어려우며, 유지 보수가 힘듬.

② Model 2

웹 어플리케이션을 개발할 때, MVC패턴을 적용하여, 웹 어플리케이션의 개발이 가능하도록 구현한 것.

- Model 2 특징 :

☞ 초기 설계에 많은 시간이 소요.

☞ 디자인코드와 비즈니스로직이 분리되며, 비즈니스로직의 재사용성이 높아짐.

☞ 비즈니스로직 계층의 확장성이 용이하며, 유지보수가 편하다.

**65. JSP 와 자바스크립트의 차이**

- JSP는 자바에서 파생된 서버스크립트 이며, 서버사이드 스크립트로서 웹 페이지를 작성하는데 사용.
- 자바스크립트는 클라이언트사이드 스크립트 이며, 브라우저의 객체를 제어하는데 쓰임.

**66. 엔티티빈(EntityBean)**

- 데이터를 객체화하여 재사용이 가능한 컴포넌트를 말함.

데이터를 객체화 한다는 것은 개발자들이 데이터에 접근하고 변경하는 방법이 보다 단순하고 쉬워진다는 것을 의미. 객체화 된 데이터를 비지니스 객체 또는 현실 세계의 객체라고하며, 이 객체는 영속성을 가진 관계형 데이터베이스에 저장이 되고, 데이터베이스에서 테이블의 한 레코드와 대응됨. 여기서 중요한 것은 빈 인스턴스와 데이터베이스의 데이터가 동기화 되어야 한다는 것. 즉, 빈 인스턴스에서 새로운 변화가 일어날 때마다 데이터베이스도 같이 갱신이 되어야 함.

**67. DB정규화의 목적**

- 자료정규화 작업의 가장 큰 목적은 자료저장의 중복성 배제이다. 정규화이론에서는 릴레이션의 형태가 여러단계로 구분되며, 가장 기본적인 정규화조건도 만족하지 못하는 릴레이션을 비정규형, 만족하는 릴레이션을 제1정규형이라고 부름. 조건이 점점 엄격해짐에 따라 제2,제3, 제4, 제5정규형으로 구분됨. 높은 단계의 정규형으로 나아갈수록 데이타의 본질적 의미가 릴레이션 구조에 보다 정확히 반영되고, 데이타 중복을 줄이고, 데이타 변경시 발생하는 문제점을 방지하고, 궁극적으로 데이타 무결성(data integrity)을 제고할 수 있다고 가정함.

**68. EJB의 사용 목적**

☞ “대규모이고 구조가 복잡한 분산 객체 환경”을 쉽게 구현하기 위해서 등장.

☞ 컴포넌트(클래스들이 모여서 생긴 하나의 기능)들의 재사용을 목적.

☞ EnterpriseBean은 이식성이 좋음.

**69. ACID (Atomic Consistent Isolated Durable)**

- 원자성, 일관성, 독립성, 지속성의 약어.

데이터베이스 트랜젝션이 안전하게 수행된다는 것을 보장하기 위한 성질.

**70. DDL (Data Definition Language)**

- 테이블 및 객체의 구조 생성 그리고 삭제, 변경과 관련된 명령어.

☞ CRATE : 새로운 테이블 생성.

☞ DROP : 기존 테이블의 구조 및 모든 행을 삭제.

☞ ALTER : 기존 테이블 변경, 필드를 추가 또는 수정 할 수 있지만 삭제 불가.

☞ TRUNCATE : 테이블의 구조를 남기고 모든 데이터 삭제.

☞ RENAME : 오브젝트의 이름을 변경.

☞ COMMENT : 테이블이나 컬럼에 주석문.

**71. DML (Data Manipulation Language)**

- 데이터 조작과 관계된 명령어.
- 데이터의 검색 및 출력, 정렬과 조인에 관계 됨.

☞ SELECT : 데이터의 조회.          ☞ INSERT : 데이터의 입력.

☞ UPDATE : 데이터의 수정.         ☞ DELETE : 데이터의 삭제.

☞ WHERE : 데이터의 조건.

☞ COMMIT : 수행한 데이터 작업들의 영구 저장.

☞ ROLLBACK : 수행한 데이터 작업들의 원상복구.

**72. DCL (Data Control Language)**

- 계정의 권한과 관계된 명령어.
- DB 사용자의 권한 정의.

☞ COMMIT : 데이터베이스 조작을 영구적으로 반영.

☞ ROLLBACK : 마지막 COMMIT 상태로 복구.

☞ GRANT : 권한 부여.             ☞ REVOKE : 권한 취소.

여기서부터 추가

**73. static**

- JVM의 static 메모리에 올라간다.
- static 메모리는 프로그램이 시작하고 종료될 때 까지 없어지지 않는다.
- 초기화 과정 필요 없이 static이 선언된 변수, 메소드에 바로 접근이 가능하다.
- 해당 객체를 공유하겠다는 의미로, 여기저기서 사용해도 동일한 객체를 사용하게 된다.
- 해당 객체를 변경하게 되면 참조하는 모든 부분에서 동일한 변경이 발생하게 되므로 주의가 필요하다.

**74. final**

- 재할당할 수 없도록 만드는 것.
- 상속 또는 초기화 이후 다시 초기화 할 수 없다.

